1007 dp
1003 dijkstra algorithm
1009 注意遍历时不能遗漏边界！尤其是表示多项式用1001长度的数组时。
1010 注意取值范围，一般题目没有给出范围都意味着可能出现大数，long long. 大数使用中也要考虑是否会溢出产生负数。
    以及用二分查找来加快速度。
1013 dfs 寻找图的连接分量数量
1014 好难哦 排队问题，考察queue的使用 技巧是使用两个变量记录最后完成的时间和能上的时间
1015 素数记得要考虑0 1 的特例。
1016 好难哦 计算时间时候要注意仔细 此题有点问题 不知为何用别人的方法先行判断是否要输出就行，用我的方法在要输出第一条时候决定是否输出就不行。
1018 此题较难，不能直接一遍迪杰斯特拉解决，原因是最后一个车站拿到的车不能用来补前面的车站，局部最优不是全局最优，需要先dijkstra再dfs搜索每一条路径相等的path
此外还要非常注意在图论题目中有时候是从1开始，循环遍历时不要因为<号漏掉最后一个。
1020 注意如何通过先序、后序、中序构造二叉树
1021 先dfs一遍，找到一组最远的节点，再任取一个节点进行dfs找到剩下的最远节点，二者取并集，注意去重。
1022
1026 https://blog.csdn.net/cstopcoder/article/details/24561377 神坑题，而且答案并不完全是题目的描述，如果多个桌子，选择的不是最小数字的而是最早空闲的。。
还有就是在判断vip的时候，要注意vip只有在到达时有空闲vip桌情况下才会优先选择vip桌。
1027 还有其他解法。
1028 神坑题 内存容易超限.只能用一个数组，而且题目明明说是long int结果还不能用, 只能用int。并且用单数组之后的循环的边界很难判断，要注意。
1033比较难的贪心算法，要考虑多种情况，一开始只考虑到了要到最便宜的站去加油。一开始没过是因为没有设置起点没有加油站的特殊情况。
1034 考察c++中map的使用，其实就是dfs即可，但是dfs的时候要带上累加的几个参数。最后有段错误是因为数组不够大。

1037 其实挺简单，一开始没有审清楚题，题目要求是不一定取所有的coupon product

1038 itoa 不能用， 难点在于如何排序，子串和父串需要互相连接再排序，这时候要注意长度保证
还有就是输出巨坑，如果0在中间就要输出，如果0在开头就不输出，如果全是0又要输出一个0

1040 动态规划题，必须找准初始化 和局部最优的方案。
1043 麻烦题 主要还是二叉搜索树的性质，这里注意指针传值问题，如果传一个指针进去在函数里malloc，传出来还是不行的，必须传指针的指针进去。
网上人方法貌似是强行构造一个二叉搜索树然后得出其先序，判断是否和原来的先序相同。
1044 比较简单，直接遍历即可，但注意有时候要适当剪枝避免超时。
1045 经典的动态规划 LCS 必须掌握

1046 很容易一道题 ，想复杂了。。。

1047 与之前的题目类似，还是注意容器，如果容易超时就少用容器、cin、cout、string等c++特性，还有注意指针如果没有重新new则是引用传递，容易丢失数据。

1049 其实是一道数学题，有丶难，考察对于数字的理解。

1050 又想复杂了，经常出现这种题，用existed数组来判断是否存在，对于ascii码也是可以的，但是字符串就不行。

1059 一定要注意有时候题目要求long 或者long long, 不仅那个变量要用long, 相关函数和输入输出也要用long.

1060 截取浮点数最好不要用浮点数的规约，因为四舍五入，以及近似存储，很多问题，建议用字符串处理的方法。

1062 注意c++的comp函数与c的comp返回值类型不一样，在处理strcmp这样的时候要注意。

1064 我是直接建树，这样做符合一般逻辑，但是有时候对于边界值的把握和调试比较难。1064niupi.c是一个更好地解法，利用了完全二叉树的性质
以及搜索树的中序遍历即为从小到大的特点。

1066高级数据结构的一些avltree 斜堆 左势堆之类的要注意复习。

1068动态规划的背包问题  f[i][j]表示0-i所装下的最大的不超过j的货物，F(N, M) = max{ F(N–1, M), F(N–1, M–c(N)) + c(N)

1070无厘头。。非常诡异，进货量非要用double来存储，但是实际过程中并没有用到int以后的精度，这只能
说提醒了考试的时候如果出现死活过不了的情况，如果涉及到一些浮点数运算的可以考虑把一些整数改成浮点数。

1078 有点坑，不过想到了， 坑点是又忘了素数判断要考虑1 2 特殊情况。

1079终极弱智题 ，其实很简单dfs bfs都行，问题是结构体里面的大数组不能直接上限，要根据实际情况malloc, 结果会报错超时而不是超限，很无语。。

1085 没看清题目，也是考察剪枝。
1086 还是没看清题目，很简单一道题，只需要按照步骤建树即可。网上似乎还有不建树解法，明天再看。
1101 此题有一定技巧，可以从头到尾从尾到头遍历两次分别得到前面最大的和后面最小的，之后再挨个比较是否满足要求即可。
还有一种办法是利用快速排序的特点，pivot位置不会再发生改变，只需要保证其前面的数都比他小即可。
1103 dfs中尽量不要用vector之类的值传递，很容易爆炸。
1104