1007 dp
1003 dijkstra algorithm
1009 注意遍历时不能遗漏边界！尤其是表示多项式用1001长度的数组时。
1010 注意取值范围，一般题目没有给出范围都意味着可能出现大数，long long. 大数使用中也要考虑是否会溢出产生负数。
    以及用二分查找来加快速度。
1013 dfs 寻找图的连接分量数量
1014 好难哦 排队问题，考察queue的使用 技巧是使用两个变量记录最后完成的时间和能上的时间
1015 素数记得要考虑0 1 的特例。
1016 好难哦 计算时间时候要注意仔细 此题有点问题 不知为何用别人的方法先行判断是否要输出就行，用我的方法在要输出第一条时候决定是否输出就不行。
1018 此题较难，不能直接一遍迪杰斯特拉解决，原因是最后一个车站拿到的车不能用来补前面的车站，局部最优不是全局最优，需要先dijkstra再dfs搜索每一条路径相等的path
此外还要非常注意在图论题目中有时候是从1开始，循环遍历时不要因为<号漏掉最后一个。
1020 注意如何通过先序、后序、中序构造二叉树
1021 先dfs一遍，找到一组最远的节点，再任取一个节点进行dfs找到剩下的最远节点，二者取并集，注意去重。
1022
1026 https://blog.csdn.net/cstopcoder/article/details/24561377 神坑题，而且答案并不完全是题目的描述，如果多个桌子，选择的不是最小数字的而是最早空闲的。。
还有就是在判断vip的时候，要注意vip只有在到达时有空闲vip桌情况下才会优先选择vip桌。

1028 神坑题 内存容易超限.只能用一个数组，而且题目明明说是long int结果还不能用, 只能用int。并且用单数组之后的循环的边界很难判断，要注意。
1033比较难的贪心算法，要考虑多种情况，一开始只考虑到了要到最便宜的站去加油。一开始没过是因为没有设置起点没有加油站的特殊情况。
1034 考察c++中map的使用，其实就是dfs即可，但是dfs的时候要带上累加的几个参数。最后有段错误是因为数组不够大。

1037 其实挺简单，一开始没有审清楚题，题目要求是不一定取所有的coupon product

1038 itoa 不能用， 难点在于如何排序，子串和父串需要互相连接再排序，这时候要注意长度保证
还有就是输出巨坑，如果0在中间就要输出，如果0在开头就不输出，如果全是0又要输出一个0

1040 动态规划题，必须找准初始化 和局部最优的方案。
1043 麻烦题 主要还是二叉搜索树的性质，这里注意指针传值问题，如果传一个指针进去在函数里malloc，传出来还是不行的，必须传指针的指针进去。
网上人方法貌似是强行构造一个二叉搜索树然后得出其先序，判断是否和原来的先序相同。
1044 比较简单，直接遍历即可，但注意有时候要适当剪枝避免超时。
1045 经典的动态规划 LCS 必须掌握

1046 很容易一道题 ，想复杂了。。。

1047 与之前的题目类似，还是注意容器，如果容易超时就少用容器、cin、cout、string等c++特性，还有注意指针如果没有重新new则是引用传递，容易丢失数据。

1049 其实是一道数学题，有丶难，考察对于数字的理解。

1050 又想复杂了，经常出现这种题，用existed数组来判断是否存在，对于ascii码也是可以的，但是字符串就不行。
